[
    {
      "instruction": "",
      "input": "# This is the assembly code of function asio::detail::binder1<helics::BrokerBase::queueProcessingLoop()::$_0, std::error_code>::operator()():\n pushq %r15\npushq %r14\npushq %rbx\nsubq $0xd0, %rsp\nmovq %rdi, %r14\nmovq (%rdi), %rbx\nmovq 0x8(%rdi), %rsi\nmovq %rsp, %r15\nmovq %r15, %rdi\ncallq 0x17fa2a\nmovq (%r15), %rax\ncmpb $0x1, (%rax)\njne 0x17e99f\nleaq 0x18(%rsp), %r15\npushq $0x7d\npopq %rsi\nmovq %r15, %rdi\ncallq 0x14eb2a\nmovq 0x18(%r14), %rax\ncmpq 0x8(%r15), %rax\njne 0x17e97b\nmovl 0x18(%rsp), %eax\ncmpl %eax, 0x10(%r14)\njne 0x17e97b\nleaq 0x18(%rsp), %rdi\npushq $0x1\npopq %rsi\ncallq 0x1b5d80\nleaq 0x18(%rsp), %rsi\norb $0x10, 0x1a(%rsi)\nmovq %rbx, %rdi\ncallq 0x17d67c\njmp 0x17e995\nleaq 0x18(%rsp), %rdi\npushq $0x1\npopq %rsi\ncallq 0x1b5d80\nleaq 0x18(%rsp), %rsi\nmovq %rbx, %rdi\ncallq 0x17de40\nleaq 0x18(%rsp), %rdi\ncallq 0x1b6104\nleaq 0x8(%rsp), %rdi\nmovq -0x8(%rdi), %rax\nmovb $0x0, 0x1(%rax)\ncallq 0xdd9e6\naddq $0xd0, %rsp\npopq %rbx\npopq %r14\npopq %r15\nretq\nmovq %rax, %rbx\nleaq 0x18(%rsp), %rdi\ncallq 0x1b6104\njmp 0x17e9e2\nmovq %rdx, %r14\nmovq %rax, %rbx\nleaq 0x18(%rsp), %rdi\ncallq 0x1b6104\njmp 0x17e9fa\nmovq %rax, %rbx\nleaq 0x8(%rsp), %rdi\ncallq 0xdd9e6\nmovq %rbx, %rdi\ncallq 0x5bb40\nmovq %rdx, %r14\nmovq %rax, %rbx\ncmpl $0x1, %r14d\njne 0x17e9e2\nmovq %rbx, %rdi\ncallq 0x5b0c0\nmovq %rax, %rbx\nmovq 0x22f576(%rip), %rdi    # 0x3adf88\nleaq 0xf655d(%rip), %rsi     # 0x274f76\ncallq 0x5ba10\nmovq %rax, %r14\nmovq (%rbx), %rax\nmovq %rbx, %rdi\ncallq *0x10(%rax)\nmovq %r14, %rdi\nmovq %rax, %rsi\ncallq 0x5ba10\npushq $0xa\npopq %rsi\nmovq %rax, %rdi\ncallq 0x5bb70\ncallq 0x5bda0\njmp 0x17e99f\njmp 0x17e9df\nmovq %rax, %rbx\ncallq 0x5bda0\njmp 0x17e9e2\nmovq %rax, %rdi\ncallq 0x6c8fd\n\n# What is the source code?\n",
      "output": "void operator()()\n  {\n    static_cast<Handler&&>(handler_)(\n        static_cast<const Arg1&>(arg1_));\n  }"
    },
    {
      "instruction": "",
      "input": "# This is the assembly code of function qpdf::Tokenizer::inNameHex1(char):\n pushq %r14\npushq %rbx\npushq %rax\nmovl %esi, %r14d\nmovq %rdi, %rbx\nmovb %r14b, 0x8c(%rdi)\nleal -0x30(%r14), %eax\ncmpb $0xa, %al\njb 0xe629a\ncmpb $0x61, %r14b\njl 0xe6287\nleal -0x57(%r14), %eax\njmp 0xe629a\nleal -0x37(%r14), %eax\ncmpb $0x41, %r14b\nmovzbl %al, %ecx\nmovl $0x10, %eax\ncmovgel %ecx, %eax\ncmpb $0xf, %al\njg 0xe62b8\nmovsbl %al, %eax\nshll $0x4, %eax\nmovl %eax, 0x88(%rbx)\nmovl $0x13, (%rbx)\naddq $0x8, %rsp\npopq %rbx\npopq %r14\nretq\nleaq 0x50(%rbx), %rdi\nmovq 0x58(%rbx), %rdx\nleaq 0x9a5e8(%rip), %rcx     # 0x1808af\nmovl $0x2f, %r8d\nxorl %esi, %esi\ncallq 0x19580\nleaq 0x10(%rbx), %rdi\nxorl %esi, %esi\ncallq 0x19d70\nmovl $0x4, (%rbx)\nmovsbl %r14b, %esi\nmovq %rbx, %rdi\naddq $0x8, %rsp\npopq %rbx\npopq %r14\njmp 0xe5b7e\n\n# What is the source code?\n",
      "output": "void\nTokenizer::inNameHex1(char ch)\n{\n    hex_char = ch;\n\n    if (char hval = util::hex_decode_char(ch); hval < '\\20') {\n        char_code = int(hval) << 4;\n        state = st_name_hex2;\n    } else {\n        QTC::TC(\"qpdf\", \"QPDFTokenizer bad name 1\");\n        error_message = \"name with stray # will not work with PDF >= 1.2\";\n        // Use null to encode a bad # -- this is reversed in QPDF_Name::normalizeName.\n        val += '\\0';\n        state = st_name;\n        inName(ch);\n    }\n}"
    }
]